import express from 'express';
import bodyParser from 'body-parser';//not needed try default does node stream parse
// import cors from 'cors'; //When using react diff port cross origin resource sharing
import pg from 'pg';
import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

dotenv.config();
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const app = express();
const port = 3000;

app.use(bodyParser.urlencoded({ extended: true }));//uses qs library obj in obj for []
app.use(express.json()); // For JSON data
app.use(express.static('../frontend/public'));
app.set("view engine", "ejs");
app.set("views", path.join(__dirname, "../frontend/views"));

const pool = new pg.Pool({ //default 100 connections
    user: process.env.DB_USER,
    host: process.env.DB_HOST,
    database: process.env.DB_NAME,
    password: process.env.DB_PASSWORD,
    port: process.env.DB_PORT,
});

pool.connect()
    .then(() => console.log("Connected to PostgreSQL"))
    .catch(err => console.error("Database connection error", err));

//homepage rendering
app.get('/', async (req, res) => {
    res.render("login.ejs");
});
//on all dashboard add a logout button
// Login Route
app.post("/login/submit", async (req, res) => {
    const { username, password, role } = req.body;

    try {
        const result = await pool.query(
            'SELECT * FROM "user" WHERE username = $1 AND password = $2',
            [username, password]
            //as the inputs in this as well as all other fields are generated by admin no threat! if you find any vulnerabilities please contact me!!!
        );

        if (result.rows.length === 0) {
            return res.render("login.ejs", { status: "false" });
        }

        const user = result.rows[0];

        return res.render("choices.ejs", { userData: user });
    } catch (err) {
        console.error("Error during login:",err);
        res.status(500).send("Server error");
    }
});

app.post("/choices/submit",async (req,res)=>{
    let {userData,gender,degree,branch,studyYear,floor,lift,mess,window_p,pod_1_preference,pod_2_preference,pod_3_preference,pod_4_preference,pod_5_preference,pod_6_preference}=req.body;


    try {
        userData = typeof
        userData === "string" ? JSON.parse(userData): userData;
    }
    catch (error) {
        console.error("Error parsing the entry:", error);
        return res.render("login.ejs",{
            userData:{},
            newEntryStatus: "false"
        });
    }

    const client = await pool.connect();
    try {
        await client.query("BEGIN");

        //insert into choices table
        const userInsertQuery='INSERT INTO choices (user_id,gender,degree,branch,study_year,floor,lift,mess,window_p) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9) ON CONFLICT (user_id) DO UPDATE SET gender = EXCLUDED.gender, degree = EXCLUDED.degree, branch = EXCLUDED.branch, study_year = EXCLUDED.study_year, floor = EXCLUDED.floor, lift = EXCLUDED.lift, mess = EXCLUDED.mess, window_p = EXCLUDED.window_p';

        await client.query(userInsertQuery,[
            userData.user_id,
            gender,
            degree,
            branch,
            studyYear,
            floor,
            lift,
            mess,
            window_p
        ]);

        if(pod_1_preference !== undefined){
            const pod1Query='INSERT INTO pod_1_table (username,pod_1_preference) VALUES ($1,$2) ON CONFLICT (username) DO UPDATE SET pod_1_preference = EXCLUDED.pod_1_preference';

            await client.query(pod1Query,[
                userData.username,
                pod_1_preference
            ]);
        }
        else if(pod_2_preference!== undefined){
            
            const pod2Query='INSERT INTO pod_2_table (username,pod_2_preference) VALUES ($1,$2) ON CONFLICT (username) DO UPDATE SET pod_2_preference = EXCLUDED.pod_2_preference';

            await client.query(pod2Query,[
                userData.username,
                pod_2_preference
            ]);
        }
        else if(pod_3_preference!== undefined){
            
            const pod3Query='INSERT INTO pod_3_table (username,pod_3_preference) VALUES ($1,$2) ON CONFLICT (username) DO UPDATE SET pod_3_preference = EXCLUDED.pod_3_preference';

            await client.query(pod3Query,[
                userData.username,
                pod_3_preference
            ]);
        }
        else if(pod_4_preference!== undefined){
            
            const pod4Query='INSERT INTO pod_4_table (username,pod_4_preference) VALUES ($1,$2) ON CONFLICT (username) DO UPDATE SET pod_4_preference = EXCLUDED.pod_4_preference';

            await client.query(pod4Query,[
                userData.username,
                pod_4_preference
            ]);
        }
        else if(pod_5_preference!== undefined){
            
            const pod5Query='INSERT INTO pod_5_table (username,pod_5_preference) VALUES ($1,$2) ON CONFLICT (username) DO UPDATE SET pod_5_preference = EXCLUDED.pod_5_preference';

            await client.query(pod5Query,[
                userData.username,
                pod_5_preference
            ]);
        }
        else if(pod_6_preference!== undefined){
            
            const pod6Query='INSERT INTO pod_6_table (username,pod_6_preference) VALUES ($1,$2) ON CONFLICT (username) DO UPDATE SET pod_6_preference = EXCLUDED.pod_6_preference';

            await client.query(pod6Query,[
                userData.username,
                pod_6_preference
            ]);
        }

        await client.query("COMMIT");

        res.render("login.ejs", {
            userData: userData ||
            {}, newEntryStatus: "true",
            status:"true"
        });

    }
    catch (error){
        await client.query("ROLLBACK");
        console.error("Transaction failed:",error);
        res.render("login.ejs",{
            userData:userData || {},
            status: "false"
        });
    }
    finally{
        client.release();
    }
});

//logout
app.get("/logout",async (req, res) => {
    res.redirect("/");
});

// Start the server
app.listen(port, () => {
    console.log(`Server running on http://localhost:${port}`);
});